<!DOCTYPE html>
<html manifest="manifest.appcache">
<head>
<!-- many thanks to https://github.com/tbicr/OfflineMap -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<link rel="apple-touch-icon" href="https://si0.twimg.com/profile_images/666603054/r.png"/>
<title>GSI Maps Offline</title>
<style>
html, body, #map {
  width: 100%; height: 100%; margin: 0; padding: 0; border: 0;
}
.cache-size-control {background-color: yellow;}
.leaflet-container{background-color: #fff; -webkit-filter: grayscale(100%) blur(0.2px) invert(100%);}</style>
<link rel="stylesheet" href="leaflet.css" />
<link rel="stylesheet" href="L.Control.Locate.css" />
<!--[if lte IE 8]>
<link rel="stylesheet" href="leaflet.ie.css"/>
<link rel="stylesheet" href="L.Control.Locate.ie.css"/>
<![endif]-->
</head>
<body>
<div id="map"></div>
<script src="leaflet.js"></script>
<script src="L.Control.Locate.js"></script>
<script>
window.offlineMaps = {};

window.offlineMaps.eventManager = {
  _events: {},
  on: function(event, action) {
    if (!(event in this._events)) {
      this._events[event] = [];
    }
    this._events[event].push(action);
    return this;
  },
  off: function(event) {
    delete this._events[event];
    return this;
  },
  fire: function(event) {
    var events = this._events;
    if (event in events) {
      var actions = events[event];
      var args = Array.prototype.slice.call(arguments, 1);
      for (var i = 0, l = actions.length; i < l; i++) {
        var action = actions[i];
        if (action instanceof Function) {
          action.apply(null, args);
        } else {
          this.fire.apply(this, [action].concat(args));
        }
      }
    }
    return this;
  }
};

(function(window, emr, undefined) {
  var getIndexedDBStorage = function() {
    var indexedDB = window.indexedDB || window.mozIndexedDB || 
      window.webkitIndexedDB || window.msIndexedDB;
    var IndexedDBImpl = function() {
      var self = this;
      var db = null;
      var request = indexedDB.open('TileStorage');
      request.onsuccess = function() {
        db = this.result;
        impl = 'IndexedDB';
        emr.fire('storageLoaded', self);
      };
      request.onerror = function(error) {
        console.log(error);
      };
      request.onupgradeneeded = function() {
        var store = this.result.createObjectStore('tile', {keyPath: 'key'});
        store.createIndex('key', 'key', { unique: true });
      };
      this.add = function(key, value) {
        var transaction = db.transaction(['tile'], 'readwrite');
        var objectStore = transaction.objectStore('tile');
        objectStore.put({key: key, value: value, date: Date.now()});
      };
      this.delete = function(key) {
        var transaction = db.transaction(['tile'], 'readwrite');
        var objectStore = transaction.objectStore('tile');
        objectStore.delete(key);
      };
      this.get = function(key, successCallback, errorCallback) {
        var transaction = db.transaction(['tile'], 'readonly');
        var objectStore = transaction.objectStore('tile');
        var result = objectStore.get(key);
        result.onsuccess = function() {
          successCallback(this.result ? this.result.value : undefined);
        };
        result.onerror = errorCallback;
      };
      this.size = function(successCallback, errorCallback) {
        var transaction = db.transaction(['tile'], 'readonly');
        var objectStore = transaction.objectStore('tile');
        var result = objectStore.count();
        result.onsuccess = function() {
          successCallback(this.result);
        };
        result.onerror = errorCallback;
      };
    };
    return indexedDB ? new IndexedDBImpl() : null;
  };

  var getWebSqlStorage = function() {
    var openDatabase = window.openDatabase;
    var WebSqlImpl = function() {
      var self = this;
      var db = openDatabase('TileStorage', '1.0', 'Tile Storage', 5 * 1024 * 1024);
      db.transaction(function(tx) {
        tx.executeSql('CREATE TABLE IF NOT EXISTS tile (key TEXT PRIMARY KEY, value TEXT, date INTEGER)', [], function() {impl = 'WebSQL'; emr.fire('storageLoaded', self);});
      });
      this.add = function(key, value) {
        db.transaction(function(tx) {
          tx.executeSql('INSERT INTO tile (key, value, date) VALUES (?, ?, ?)', [key, value, Date.now()]);
        });
      };
      this.delete = function(key) {
        db.transaction(function(tx) {
          tx.executeSql('DELETE FROM tile WHERE key = ?', [key]);
        });
      };
      this.get = function(key, successCallback, errorCallback) {
        db.transaction(function(tx) {
          tx.executeSql('SELECT value FROM tile WHERE key = ?', [key], 
            function(tx, result) {
              successCallback(result.rows.length ? 
                result.rows.item(0).value : undefined);}, 
            errorCallback);
        });
      };
      this.size = function(successCallback, errorCallback) {
        db.transaction(function(tx) {
          tx.executeSql('SELECT count(*) FROM tile;', [],
            function(tx, result) {
              successCallback(result.rows.item(0)['count(*)'])}, 
            errorCallback);
        });
      };
    };
    return openDatabase ? new WebSqlImpl() : null;
  };

  emr.on('storageLoad', function() {
    storage =  getIndexedDBStorage() || getWebSqlStorage() || null;
    if (!storage) {emr.fire('storageLoaded', null);}
  });
})(window, window.offlineMaps.eventManager);

(function(window, emr, L, undefined) {
  var StorageTileLayer = L.TileLayer.extend({
    _imageToDataUri: function(image) {
      var canvas = window.document.createElement('canvas');
      canvas.width = image.width;
      canvas.height = image.height;
      var context = canvas.getContext('2d');
      context.drawImage(image, 0, 0);
      return canvas.toDataURL('image/png');
    },

    _tileOnLoadWithCache: function() {
      var storage = this._layer.options.storage;
      if (storage) {
        storage.add(this._storageKey, this._layer._imageToDataUri(this));
      }
      L.TileLayer.prototype._tileOnLoad.apply(this, arguments);
    },

    _setUpTile: function(tile, key, value, cache) {
      tile._layer = this;
      if (cache) {
        tile._storageKey = key;
        tile.onload = this._tileOnLoadWithCache;
        tile.crossOrigin = 'Anonymous';
      } else {
        tile.onload = this._tileOnLoad;
      }
      tile.onerror = this._tileOnError;
      tile.src = value;
    },

    _loadTile: function(tile, tilePoint) {
      this._adjustTilePoint(tilePoint);
      var key = this.options.tn + '-' + tilePoint.z + '-' + tilePoint.x + '-' + tilePoint.y;
      var self = this;
      if (this.options.storage) {
        this.options.storage.get(key, function(value) {
          if (value) {
            self._setUpTile(tile, key, value, false);
          } else {
            self._setUpTile(tile, key, self.getTileUrl(tilePoint), true);
          }
        }, function() {
          self._setUpTile(tile, key, self.getTileUrl(tilePoint), true);
        });
      } else {
        self._setUpTile(tile, key, self.getTileUrl(tilePoint), false);
      }
    }
  });

  emr.on('mapLoad', function(storage) {
    map = L.map('map').setView([36, 140], 7);
    new StorageTileLayer('http://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {attribution: '国土地理院', storage: storage, tn: 'std'}).addTo(map);
    L.control.locate({follow: true, stopFollowingOnDrag: true, position: 'bottomright'}).addTo(map);
    map.zoomControl.setPosition('bottomright');
    storage.size(map.attributionControl.addAttribution, alert);
    
    var CacheSizeControl = L.Control.extend({
      options: {position: 'bottomleft'},
      onAdd: function(map) {
        var c = L.DomUtil.create('div', 'cache-size-control');
        c.appendChild(document.createTextNode('-'));
        map.on('moveend', function() {
          storage.size(function(size) {
            c.removeChild(c.firstChild);
            c.appendChild(document.createTextNode(
              size + ' tiles in offline cache'));
          }, function() {})
        });
        map.fire('moveend');
        return c;
      }
    });
    csc = new CacheSizeControl();
    map.addControl(csc);

    emr.fire('mapLoaded');
  });
})(window, window.offlineMaps.eventManager, L);

(function(emr) {
  emr.on('storageLoaded', 'mapLoad');
  emr.fire('storageLoad');
})(window.offlineMaps.eventManager);
</script>
</body>
</html>
