<!DOCTYPE html>
<html manifest="manifest.appcache">
<head>
<!-- many thanks to https://github.com/tbicr/OfflineMap -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<link rel="apple-touch-icon" href="https://si0.twimg.com/profile_images/666603054/r.png"/>
<title>GSI Maps with Cache</title>
<style>
html, body, #map {
  width: 100%; height: 100%; margin: 0; padding: 0; border: 0;
}
div.leaflet-control-layers,div.leaflet-control-zoom, div.leaflet-control-locate {background: rgba(255, 255, 255, 0.75); -webkit-filter: opacity(0.61)}
.cache-size-control {background: rgba(255, 255, 0, 0.61);}
.leaflet-container{background: #fff;}// -webkit-filter: grayscale(100%) blur(0.2px) invert(100%);}
</style>
<link rel="stylesheet" href="leaflet.css" />
<link rel="stylesheet" href="L.Control.Locate.css" />
<link rel="stylesheet" href="l.geosearch.css" />
<!--[if lte IE 8]>
<link rel="stylesheet" href="leaflet.ie.css"/>
<link rel="stylesheet" href="L.Control.Locate.ie.css"/>
<![endif]-->
</head>
<body>
<div id="map"></div>
<script src="leaflet.js"></script>
<script src="L.Control.Locate.js"></script>
<script src="l.control.geosearch.js"></script>
<script src="l.geosearch.provider.esri.js"></script>
<script>
window.offlineMaps = {};

window.offlineMaps.eventManager = {
  _events: {},
  on: function(event, action) {
    if (!(event in this._events)) {
      this._events[event] = [];
    }
    this._events[event].push(action);
    return this;
  },
  off: function(event) {
    delete this._events[event];
    return this;
  },
  fire: function(event) {
    var events = this._events;
    if (event in events) {
      var actions = events[event];
      var args = Array.prototype.slice.call(arguments, 1);
      for (var i = 0, l = actions.length; i < l; i++) {
        var action = actions[i];
        if (action instanceof Function) {
          action.apply(null, args);
        } else {
          this.fire.apply(this, [action].concat(args));
        }
      }
    }
    return this;
  }
};

(function(window, emr, undefined) {
  var getIndexedDBStorage = function() {
    var indexedDB = window.indexedDB || window.mozIndexedDB || 
      window.webkitIndexedDB || window.msIndexedDB;
    var IndexedDBImpl = function() {
      var self = this;
      var db = null;
      var request = indexedDB.open('TileStorage');
      request.onsuccess = function() {
        db = this.result;
        impl = 'IndexedDB';
        emr.fire('storageLoaded', self);
      };
      request.onerror = function(error) {
        console.log(error);
      };
      request.onupgradeneeded = function() {
        var store = this.result.createObjectStore('tile', {keyPath: 'key'});
        store.createIndex('key', 'key', { unique: true });
      };
      this.add = function(key, value) {
        var transaction = db.transaction(['tile'], 'readwrite');
        var objectStore = transaction.objectStore('tile');
        objectStore.put({key: key, value: value, date: Date.now()});
      };
      this.delete = function(key) {
        var transaction = db.transaction(['tile'], 'readwrite');
        var objectStore = transaction.objectStore('tile');
        objectStore.delete(key);
      };
      this.get = function(key, successCallback, errorCallback) {
        var transaction = db.transaction(['tile'], 'readonly');
        var objectStore = transaction.objectStore('tile');
        var result = objectStore.get(key);
        result.onsuccess = function() {
          successCallback(this.result ? this.result.value : undefined);
        };
        result.onerror = errorCallback;
      };
      this.size = function(successCallback, errorCallback) {
        var transaction = db.transaction(['tile'], 'readonly');
        var objectStore = transaction.objectStore('tile');
        var result = objectStore.count();
        result.onsuccess = function() {
          successCallback(this.result);
        };
        result.onerror = errorCallback;
      };
    };
    return indexedDB ? new IndexedDBImpl() : null;
  };

  var getWebSqlStorage = function() {
    var openDatabase = window.openDatabase;
    var WebSqlImpl = function() {
      var self = this;
      var db = openDatabase('TileStorage', '1.0', 'Tile Storage', 5 * 1024 * 1024);
      db.transaction(function(tx) {
        tx.executeSql('CREATE TABLE IF NOT EXISTS tile (key TEXT PRIMARY KEY, value TEXT, date INTEGER)', [], function() {impl = 'WebSQL'; emr.fire('storageLoaded', self);});
      });
      this.add = function(key, value) {
        db.transaction(function(tx) {
          tx.executeSql('INSERT INTO tile (key, value, date) VALUES (?, ?, ?)', [key, value, Date.now()]);
        });
      };
      this.delete = function(key) {
        db.transaction(function(tx) {
          tx.executeSql('DELETE FROM tile WHERE key = ?', [key]);
        });
      };
      this.get = function(key, successCallback, errorCallback) {
        db.transaction(function(tx) {
          tx.executeSql('SELECT value FROM tile WHERE key = ?', [key], 
            function(tx, result) {
              successCallback(result.rows.length ? 
                result.rows.item(0).value : undefined);}, 
            errorCallback);
        });
      };
      this.size = function(successCallback, errorCallback) {
        db.transaction(function(tx) {
          tx.executeSql('SELECT count(*) FROM tile;', [],
            function(tx, result) {
              successCallback(result.rows.item(0)['count(*)'])}, 
            errorCallback);
        });
      };
    };
    return openDatabase ? new WebSqlImpl() : null;
  };

  emr.on('storageLoad', function() {
    storage =  getIndexedDBStorage() || getWebSqlStorage() || null;
    if (!storage) {emr.fire('storageLoaded', null);}
  });
})(window, window.offlineMaps.eventManager);

(function(window, emr, L, undefined) {
  var StorageTileLayer = L.TileLayer.extend({
    _imageToDataUri: function(image) {
      var canvas = window.document.createElement('canvas');
__image__ = image;
      canvas.width = image.width;
      canvas.height = image.height;
      var context = canvas.getContext('2d');
      context.drawImage(image, 0, 0);
      return canvas.toDataURL('image/png'); // anyway
//      return canvas.toDataURL('image/' + image.src.slice(-3));
    },

    _tileOnLoadWithCache: function() {
      var storage = this._layer.options.storage;
      if (storage) {
        storage.add(this._storageKey, this._layer._imageToDataUri(this));
      }
      L.TileLayer.prototype._tileOnLoad.apply(this, arguments);
    },

    _setUpTile: function(tile, key, value, cache) {
      tile._layer = this;
      if (cache) {
        tile._storageKey = key;
        tile.onload = this._tileOnLoadWithCache;
        tile.crossOrigin = 'Anonymous';
      } else {
        tile.onload = this._tileOnLoad;
      }
      tile.onerror = this._tileOnError;
      tile.src = value;
    },

    _loadTile: function(tile, tilePoint) {
      this._adjustTilePoint(tilePoint);
      var key = this.options.tn + '-' + tilePoint.z + '-' + tilePoint.x + '-' + tilePoint.y;
      var self = this;
      if (this.options.storage) {
        this.options.storage.get(key, function(value) {
          if (value) {
            self._setUpTile(tile, key, value, false);
          } else {
            self._setUpTile(tile, key, self.getTileUrl(tilePoint), true);
          }
        }, function() {
          self._setUpTile(tile, key, self.getTileUrl(tilePoint), true);
        });
      } else {
        self._setUpTile(tile, key, self.getTileUrl(tilePoint), false);
      }
    }
  });

  emr.on('mapLoad', function(storage) {
    var CacheSizeControl = L.Control.extend({
      options: {position: 'bottomleft'},
      onAdd: function(map) {
        var c = L.DomUtil.create('div', 'cache-size-control');
        c.appendChild(document.createTextNode('-'));
        map.on('moveend', function() {
          storage.size(function(size) {
            c.removeChild(c.firstChild);
            c.appendChild(document.createTextNode(
              size + ' tiles in cache / z = ' + map.getZoom()));
          }, function() {})
        });
        map.fire('moveend');
        return c;
      }
    });
    csc = new CacheSizeControl();

    var os = [
      {name: 'std', ext: 'png'},
      {name: 'pale', ext: 'png'},
      {name: 'std2012', ext: 'png'},
      {name: 'blank', ext: 'png'},
      {name: 'english', ext: 'png'},
      {name: 'relief', ext: 'png'},
      {name: 'ort', ext: 'jpg'},
      {name: 'gazo1', ext: 'jpg'},
      {name: 'gazo2', ext: 'jpg'},
      {name: 'gazo3', ext: 'jpg'},
      {name: 'gazo4', ext: 'jpg'},
      {name: 'toho1', ext: 'jpg'},
      {name: 'toho2', ext: 'jpg'}
    ];
    var layers = {};
    for(i in os) {
      var o = os[i];
      var layer = new StorageTileLayer('http://cyberjapandata.gsi.go.jp/xyz/' + o.name + '/{z}/{x}/{y}.' + o.ext, {attribution: "<a href='http://portal.cyberjapan.jp/help/termsofuse.html'>地理院タイル</a>", storage: storage, tn: o.name});
      layers[o.name] = layer;
      os[i] = layer;
    }
    map = L.map('map', {center: [36, 140], zoom: 7, layers: layers['std']});
//    map.addControl(csc);
//    new L.Control.GeoSearch({provider: new L.GeoSearch.Provider.Esri(), position: 'topleft', showMarker: false}).addTo(map);
    L.control.layers(layers, null, {position: 'topright'}).addTo(map);
//    L.control.locate({follow: true, stopFollowingOnDrag: true, position: 'bottomright'}).addTo(map);
    map.zoomControl.setPosition('bottomright');
    storage.size(map.attributionControl.addAttribution, alert);
    
    emr.fire('mapLoaded');
  });
})(window, window.offlineMaps.eventManager, L);

(function(emr) {
  emr.on('storageLoaded', 'mapLoad');
  emr.fire('storageLoad');
})(window.offlineMaps.eventManager);
</script>
</body>
</html>
